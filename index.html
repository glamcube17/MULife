<!DOCTYPE HTML>
<html>
<head> 
	<meta charset='UTF-8'/>
    <html lang='en'>
	<title>μLife</title>
	
    <link rel='stylesheet' href='css/jquery-ui.css'>
	<link rel='stylesheet' 
			href='css/jquery-ui-1.12.icon-font.css' />    
	<link rel='stylesheet' href='css/uibase.css'>
			
	<!--
    <script type='text/javascript' src='jscript/jquery-1.11.0.min.js'></script>
	
	<script type='text/javascript' 
	src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js'></script>
	-->
	
    <script type='text/javascript' src='javascript/jquery.js'></script>
    <script type='text/javascript' src='javascript/jquery-ui.js'></script>

	<!--
    <script type='text/javascript' src='javascript/ui.js'></script>
    -->
	
	<style>
		html, body {
			width: 95%;
			height: 95%;
			margin: 0;
			border: 0;
			padding: 5px;
			<!-- overflow: hidden; <!-- no scroll bars --> -->
			display: block;
			font-size: 125%;
			font-family: Verdana, Geneva, sans-serif;
		}
		.row {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			width: 100%;
		}
		.column {
			display: flex;
			flex-direction: column;
			flex-basis: 100%;
			flex: 1;
		}
		.button{
			font-size: 70%;
			display: inline-block;
			text-align: center;
			padding: 0px 12px;
			margin: 2px 12px;
			background-color: #4C50AF;
			border: none;
			color: white;
		}
		.field{
			font-size: 150%;
			resize: none;
			overflow: auto;
		}
	</style>
	
</head>



<body>
<div class='container'>
	<div class='row'>

		<div class='column' style='flex:0.25'>
			<div class='stretch'>
				<div class='stretch-container' style='flex:2'>
					<div class='canvas-div'>
						<canvas id='life-canvas' height='128' width='128'>
								Oops! Canvas not supported. Try Firefox!
						</canvas>
						
					</div>
				</div>
			</div>
		</div>
		<div class='column' style='background-color:#ddd; flex:1.5; padding-left: 0.5vw'>
			
			<div class='titlebar'>

				<h1 class='center-content'>μLife</h1>
				<h4 class='center-content'>LMouse: Toggle cell | r: Randomize board | C: Clear board | I: Invert board</h4>
				<h4 class='center-content'>Enter: 1-Step | Space: Auto-step | -/=: Slow/speed auto-step rate</h4>
				<h4 class='center-content'>[]: Zoom | Arrow keys: Pan</h4>
				<h4 class='center-content'>u: Toggle server sync</h4>
				<!-- <h4 class='center-content'> n/N: Add/remove random noise</h4> -->
				<!-- <h4 class='center-content'> H: Toggle Life/HighLife</h4> -->
				
				<!-- <h4 class='center-content'>LMouse: Toggle cell | Enter: Toggle step | Space: 1-step | -/=: Slow/speed auto-step rate</h4> -->
			</div>
			<br />
				<!-- <input type="checkbox" name="highLifeCheckbox" value="HighLife" />HighLife -->
			<div class='row'>
				<div class='column' style='flex:0.5'>
					<div class='container' style='background-color:inherit'>
						<h4>Survive/Born rules</h4>
						<textarea class='field' name='sbIO' id='sbIO' cols='16' rows='1' placeholder='S 23/B 3'>23/3</textarea>
						<div class='row'>
						<button class='button' class='column' onclick='setSBrules()'>Apply</button>
						</div>
						<br />
						
						<h4>Save/Load current board</h4>
						<textarea class='field' name='channelIO' id='channelIO' cols='16' rows='1' placeholder='board name'></textarea>
						<div class='row'>
						<button class='button' class='column' onclick='boardname = channelIO.value.replace("/","_") || "default"; postboard();'>Save</button>
						<button class='button' class='column' onclick='boardname = channelIO.value.replace("/","_") || "default"; fetchupdate();'>Load</button>
						</div>
						<br />
						
						<h4>Import/Export plaintext</h4>
						<textarea class='field' name='iotextbox' id='iotextbox' cols='16' rows='1' placeholder='serialized data' onclick='textbox.select();'></textarea>
						<div class='row'>
						<button class='button' class='column' onclick='deserialize(textbox.value)'>Import</button>
						<button class='button' class='column' onclick='textbox.value = serialize()'>Export</button>
						</div>
					</div>
				</div>
				<div class='column'>
					
				</div>
			</div>
				
		</div>
	</div>
</div>


	<script>
	
	var canvas = $("canvas")[0];
	var context = canvas.getContext("2d");

	context.save();
	
	let s = Math.min(window.innerWidth, window.innerHeight) * 0.95; //square
	canvas.width  = s;
	canvas.height = s;

	context.fillStyle='black';
	context.fillRect(0,0,context.canvas.width, context.canvas.height);
	
	
	var textbox = document.getElementById("iotextbox");
	var chanbox = document.getElementById("channelIO");
	var rulebox = document.getElementById("sbIO");
	<!-- var survbox = document.getElementById("survIO"); -->
	<!-- var bornbox = document.getElementById("bornIO"); -->
	textbox.contentEditable = "true";
	chanbox.contentEditable = "true";
	rulebox.contentEditable = "true";
	<!-- survbox.contentEditable = "true"; -->
	<!-- bornbox.contentEditable = "true"; -->
	
	var boardname = channelIO.value || 'default';
	
	// "COLLABORATIVE web-based multi-user"
	
	
	// @todo add nice-looking buttons to impress people / improve interface
	// @todo add multiple colors
	// @todo save initial state before stepping through?

	// @todo save or load states to/from server with custom names
	// @TODO multiple channels - create/join
	
	// @todo sync rules for each channel?
	
	// customizable base colors
	
	// web server
	// paper
	
	// demo
	// have it running on some computers and people can mess with it
	
	
	const N = 128;
	var cnt=0;
	
	var autoStepping = false;
	var autoFetching = false; //true for prod
	var autoStepRate = 0;
	
	var surv = [2,3];
	var born = [3];
	
	const celw = context.canvas.width/N;
	const celh = context.canvas.height/N;
	
	var viewscl = 1.00;
	var panX = 0; 
	var panY = 0;
	
	var noiseRate = 0;
	
	context.restore();
	
	//initialize state
	var cells = [];
	var cellneighbors = [];
	
	for(let i=0; i<N; i++){
		let row = [];
		for(let j=0; j<N; j++){
			row.push(false);
		}
		cells.push(row);
		row = [];
		for(let j=0; j<N; j++){
			row.push(0);
		}
		cellneighbors.push(row);
	}
	setSBrules(); //text entered in boxes reapplied on refresh
	autoStep();
	autoFetch();
	
	canvas.addEventListener("click", function(click){
		let i = Math.floor( ( click.offsetX - panX ) / viewscl / celw );
		let j = Math.floor( ( click.offsetY - panY ) / viewscl / celh );
		setCell(i,j,!cells[i][j]);
		redraw();
		if(autoFetching){ //syncing
			postchange(i,j,!cells[i][j]);
		}
	});
	
	
	addEventListener("keydown", function(ev){
		if(ev.ctrlKey || ev.altKey){return;}
		if($( document.activeElement ).filter('input,textarea').length > 0){return;}
		switch(ev.key){
		case "Enter":
			if(ev.shiftKey){
				autoStepping = !autoStepping;
			}else{
				doStep();
			}
			break;
		case "r": case "R":
			randomizeBoard((Math.random()+0.6)/2);
			break;
		case " ":
			ev.preventDefault(); //prevent space scrolling down
		<!-- case "a": case "A": -->
			autoStepping = !autoStepping;
			break;
		case "=":
			autoStepRate = Math.max(0,autoStepRate-10);
			break;
		case "-":
			autoStepRate = Math.min(1000,autoStepRate+10);
			break;
		case "C":
			clearBoard();
			break;
		case "I":
			invertBoard();
			break;
		case "u": case "U":
			autoFetching = !autoFetching;
			break;
		<!-- case "n": //@todo move this to a button or something -->
			<!-- noiseRate = Math.min(100,noiseRate+1); -->
			<!-- break; -->
		<!-- case "N": -->
			<!-- noiseRate = Math.max(0,noiseRate-1); -->
			<!-- break; -->
		case "[":
			if(viewscl > 0.75){
				panX -= s/2/viewscl; panY -= s/2/viewscl;
				let absx = s-(s/2+panX/viewscl);
				let absy = s-(s/2+panY/viewscl);
				viewscl = Math.max( viewscl/1.1, 0.75 );
				panX = (s - absx - s/2) * viewscl;
				panY = (s - absy - s/2) * viewscl;
				panX += s/2/viewscl; panY += s/2/viewscl;
				redraw();
			}
			break;
		case "]":
			if(viewscl < 10){
				panX -= s/2/viewscl; panY -= s/2/viewscl;
				let absx = s-(s/2+panX/viewscl);
				let absy = s-(s/2+panY/viewscl);
				viewscl = Math.min( viewscl*1.1, 10 );
				panX = (s - absx - s/2) * viewscl;
				panY = (s - absy - s/2) * viewscl;
				panX += s/2/viewscl; panY += s/2/viewscl;
				redraw();
			}
			break;
		case "ArrowLeft": case "ArrowRight": case "ArrowUp": case "ArrowDown":
			ev.preventDefault(); //prevent window from scrolling
			let absx = s-(s/2+panX/viewscl);
			let absy = s-(s/2+panY/viewscl); 
			switch(ev.key){
				case "ArrowLeft":
					if(absx >= 0){
						panX += s/N*viewscl;
					}
					break;
				case "ArrowRight":
					if(absx <= s){
						panX -= s/N*viewscl;
					}
					break;
				case "ArrowUp":
					if(absy >= 0){
						panY += s/N*viewscl;
					}
					break;
				case "ArrowDown":
					if(absy <= s){
						panY -= s/N*viewscl;
					}
					break;
			}
			redraw();
			break;
		}
	});
	
	window.addEventListener("resize", ()=>{
		let s = Math.min(window.innerWidth, window.innerHeight) * 0.95; //square
		canvas.width  = s;
		canvas.height = s;
		redraw();
	});
	
	var redrawingFlag = 0; //to avoid wasting effort on multiple asynchronous redraws at once
	function redraw(){
		if(redrawingFlag++ > 0){ return; }
		context.save();
		context.fillStyle="#000000";
		context.fillRect(0,0,s,s);
		context.translate(panX,panY);
		<!-- context.translate(s/2,s/2); -->
		context.scale(viewscl,viewscl);
		<!-- context.translate(-s/2,-s/2); -->
		for(let i=0; i < N; i++){ 
			for(let j=0; j < N; j++){
				let isalive = ( !!(cells[i][j]) == true );
				if(isalive){
					context.fillStyle="#66ccff";
				}else{
					context.fillStyle="#6611"+(4*(((i+j)%2)))+"1";
				}
				context.fillRect(i*celw,j*celh,celw,celh);
			}
		}
		context.restore();
		--redrawingFlag;
	}
	
	
	
	//Step through the state
	function doStep(){
		for(let i = 0; i < N; i++){
			for(let j = 0; j < N; j++){
				let neighborcount = 0;
				//count neighbors
				for(let I = -1; I < 2; I++){
					for(let J = -1; J < 2; J++){
						if( (I!=0||J!=0) && ( cells[(N+i+I)%N][(N+j+J)%N] === true ) ){
							neighborcount++;
						}
					}
				}
				cellneighbors[i][j] = neighborcount;
			}
		}
		
		if(noiseRate > 0 && cnt%(101-noiseRate)==0){addNoise();}
		
		for(let i=0; i < N; i++){ 
			for(let j=0; j < N; j++){
				let wasalive = ( cells[i][j] == true );
				let neighbors = cellneighbors[i][j];
				<!-- let isalive = !!( neighbors == 3 || ( neighbors == 2 && wasalive ) || highLife && neighbors == 6 ); -->
				<!-- let isalive = ( wasalive && $.inArray(neighbors, surv)!==-1 ) || ( $.inArray(neighbors, born)!==-1 ); -->
				let isalive = ( wasalive && $.inArray(neighbors, surv)!==-1 ) || ( !wasalive && $.inArray(neighbors, born)!==-1 );
				cells[i][j] = isalive;
				
				<!-- if(isalive){ -->
					<!-- context.fillStyle="#66ccff"; -->
				<!-- }else if(wasalive && !autoStepping){ -->
					<!-- context.fillStyle="#993311"; -->
				<!-- }else{ -->
					<!-- context.fillStyle="#6611"+(4*(((i+j)%2)))+"1"; -->
				<!-- } -->
				<!-- context.fillRect(i*celw,j*celh,celw,celh); -->
			}
		}
		<!-- <!-- fill outside board in black in case of zooming around leaving weirdness --> -->
		<!-- context.fillStyle="#000000"; -->
		<!-- context.fillRect(  -1*s, -1*s, 2*s, 1*s); //top edge -->
		<!-- context.fillRect(  -1*s, -1*s, 1*s, 2*s); //left edge -->
		<!-- context.fillRect(   1*s,  0*s, 1*s, 2*s); //right edge -->
		<!-- context.fillRect(   0*s,  1*s, 2*s, 1*s); //bottom edge -->
		
		redraw();
		
		cnt++;
		return;
	}
	
	
	async function autoStep(){
		while(true){
			while(autoStepping){
				await doStep();
				await sleep(autoStepRate);
			}
			while(!autoStepping){
				await sleep(autoStepRate+1);
			}
		}
	}
	
	async function autoFetch(){
		while(true){
			while(autoFetching){
				await fetchupdate();
				await sleep(2000);
			}
			while(!autoFetching){
				await sleep(200);
			}
		}
	}
	
	
	
	
	function setCell(i,j,state){
		if(i >= N || j >= N || i < 0 || j < 0){ return; }
		cells[i][j] = state;
		if(state === true){
			context.fillStyle="#66ccff";
		}else{
			context.fillStyle="#6611"+(4*(((i+j)%2)))+"1";
		}
		context.fillRect(i*celw,j*celh,celw,celh);
	}
	
	function randomizeBoard(ratio){
		for(let i = 0; i < N; i++){
			for(let j = 0; j < N; j++){
				setCell(i,j,( Math.random() < ratio ) );
			}
		}
		redraw();
	}
	
	function clearBoard(){
		for(let i = 0; i < N; i++){
			for(let j = 0; j < N; j++){
				setCell(i,j,false);
			}
		}
	}
	
	function invertBoard(){
		for(let i = 0; i < N; i++){
			for(let j = 0; j < N; j++){
				setCell(i,j,!cells[i][j]);
			}
		}
		redraw();
	}
	
	
	function addNoise(){
		let num = Math.floor(Math.random()*Math.pow(noiseRate,0.5));
		let x = Math.floor(Math.random()*N);
		let y = Math.floor(Math.random()*N);
		setCell(x,y,true);
	}
	
	
	function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
	
	
	
	function serialize(){
		let str = "";
		for(let j=0; j<N; j++){
			for(let i=0; i<N; i++){
				str = str + ( cells[i][j] ? "O":"." );
			}
			str = str + '\n';
		}
		<!-- textbox.value = str; -->
		<!-- textbox.select(); -->
		<!-- document.execCommand("copy"); -->
		return str;
	}
	function deserialize(str){
		let i0 = 0; let j0 = 0;
		<!-- if(str.split(',').length > 1){ -->
			<!-- i0 = Number(str.split(',')[0]); -->
			<!-- j0 = Number(str.split(',')[1]); -->
			<!-- str = str.split(',')[2]; -->
		<!-- } -->
		
		let c = 0; let C = Math.min(str.length, (N-i0)*(N-j0));
		let i = i0; let j = j0; let c0 = 0;
		if(str[0] == '\n'){ c0 = 1; }
		for(c = c0; c < C; c++){
			switch(str[c]){
				case 'O':
					setCell(i,j,true);
					i++;
					break;
				case '.':
					setCell(i,j,false);
					i++;
					break;
				case '\n': case '/': case ',':
					j++;
					i=i0;
					break;
				case ' ':
					i++;
					break;
			}
			
		}
	}
	
	function setSBrules(){
		let sb = (' '+rulebox.value.replace(/[^\d\/]/g,'')+' ').split('/');
		<!-- let survstr = survbox.value.replace(/[^\d]/g,''); -->
		<!-- let bornstr = bornbox.value.replace(/[^\d]/g,''); -->
		let survstr = sb[0];
		let bornstr = sb[1];
		surv = [];
		born = [];
		for(i = 0; i < survstr.length; i++){ surv.push(parseInt(survstr[i])); }
		for(i = 0; i < bornstr.length; i++){ born.push(parseInt(bornstr[i])); }
	}
	
	
	
	
	function fetchupdate() {
		xhr = new XMLHttpRequest();
		xhr.open("GET","http://localhost:8001/getboard?name="+boardname, true);
		xhr.onreadystatechange=function(){
			if (xhr.readyState==4 && xhr.status==200){
				<!-- let params = url.parse(xhr.url, true).query; -->
				<!-- let str = xhr.responseText; -->
				let data = JSON.parse(xhr.responseText);
				console.log(data);
				let str = data.state.join('\n');
				rulebox.value = data.survive + '/' + data.born;
				<!-- survbox.value = data.survive; -->
				<!-- bornbox.value = data.born; -->
				deserialize(str);
				setSBrules();
				//@todo if timer expired, stop updating, lock changes, and start stepping through
			}
		}
		xhr.send();
	}
	fetchupdate();
	
	
	function postchange(x,y,state) {
		xhr = new XMLHttpRequest();
		xhr.open("POST","http://localhost:8001/changeboard?x="+x+"&y="+y+"&state="+state+"&name="+boardname, true);
		xhr.send();
	}
	
	function postboard() {
		xhr = new XMLHttpRequest();
		xhr.open("POST","http://localhost:8001/setboard?name="+boardname, true);
		<!-- let data = serialize(); -->
		let data = JSON.stringify( { "name":boardname, "survive":surv.toString, "born":born.toString, "state":serialize().split('\n') } );
		xhr.send(data);
	}
	
	
	
	</script>
	
  </body>
</html>